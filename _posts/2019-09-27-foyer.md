---
title: 'Molecular Modelling Software: Foyer'
date: 2019-09-27
permalink: /posts/2019/09/foyer1/
tags:
  - molecularModelling
  - scientificComputing
  - gradSchool
---

# Foyer
Foyer is an [open-source Python package](https://github.com/mosdef-hub/foyer/tree/master/foyer), part of the 
[MoSDeF](http://mosdef.org/) suite of tools for molecular modelling.
In the description: "package for atom-typing as well as applying and 
disseminating forcefields."

## Reading Check
If you don't know what atom types or force field parameters are,
I suggest reading [this post](https://ahy3nz.github.io/posts/2019/08/parmed1/)
to catch up. 
If you're new to molecular modelling, try 
[this](https://ahy3nz.github.io/posts/2019/07/mm1/)
or [that](https://ahy3nz.github.io/posts/2019/07/mm2/)

## Overview
The basic idea behind Foyer is to assign atom types and force field (FF)
parameters given an arbitrary chemical topology (bonding network).
Anyone who has worked in modeling knows this is a daily frustration.
Further, the process is aimed at being transparent - how each atomtype
gets chosen, what the various force field parameters are - and 
easily share-able - a Python script that constructs your system
and utilizes Foyer to atomtype and parametrize accroding to
a share-able, human-readable force field file (XML-style).

For most molecular modellers, we rely on other software like
antechamber, ligpargen, charmm-gui, cgenff, etc. to atomtype
and parametrize.
In goes the structure, out come the FF parameters, and pray it works.
Fairly black box, no flexible API to modify the process.
For as complicated as we will see the Foyer API to be, the
underlying FF parameters and atom types are easy to debug and modify.
As it stands (September 2019), there is good support for 
the OPLS-AA force field provided wiht Foyer, and more in development.
Contributions from others are always welcome, especially
trying to get the more general force fields codified and shared.

This post is going to start from general Foyer API and work flow
to finer-detailed explanations of particular routines.
So hop on the train and feel free to hop off as you see fit.
For users, you might not need to read the whole thing.
For debuggers, developers, and maintainers, it might help to stay to the end.
If you wanted code-examples and tutorials, I recommend you look
through the MoSDeF organization and Foyer repos. 
There are lots.

## The Foyer force field XML
A molecular mechanics force field defines the atoms and atom types 
within a chemical system. 
The Foyer force field XML derives and builds upon the 
[OpenMM force field XML](http://docs.openmm.org/7.0.0/userguide/application.html#writing-the-xml-file)
Furthermore, the interaction parameters are also specified
(bonds, angles, dihedrals, nonbonded interactions).
The available functional forms and units are 
based on [OpenMM style](http://docs.openmm.org/latest/userguide/theory.html).
Foyer-supported parameters are [here](https://github.com/mosdef-hub/foyer/blob/master/docs/parameter_definitions.rst)

Below is a small example of an XML file ![ffxml](/images/foyer/ffxml.png)

The heading `<AtomTypes>` defines the different atom types within the FF.
The attribute `name` defines the name of the atom type, and it is
*unique*. 
No other atom types can have the same name.
The attribute `class` defines a broad category that can encompass
multiple atom types (notice how there are multiple `class="CT"`).
Multiple atom types can belong to the same class, and this can help
down the line if you want to assign parameters to an entire class,
not just a specific, unique atom type.
`Mass` is self-explanatory, amu.
`desc` is a human-readable description to help understand the atomtype.
There is also an additional `doi` attribute, which is useful
for citing the relevant papers where those FF parameters were published.

`def` and `overrides` are where Foyer really makes its money.
Foyer-documentation [here](https://github.com/mosdef-hub/foyer/blob/master/docs/smarts.rst).
`def` refers to a **SMARTS string** that defines the bonding and
chemical context of the atom of interest.
At its most basic, you could use SMARTS strings to uniquely define
sp3, sp2, and sp hybridized carbons (4, 3, and 2 bonded partners, respectively).
SMARTS is not developed by the MoSDeF group, but rather utilized by us.
SMARTS is similar to SMILES in that they are strings that define
chemistry, but SMILES defines molecules; SMARTS defines patterns.
SMARTS theory [here](https://www.daylight.com/dayhtml/doc/theory/theory.smarts.html).
There is a lot of chemistry/bonding that can be defined via SMARTS, only
a [subset is supported in Foyer so far](https://github.com/mosdef-hub/foyer/issues/63).
In the image posted above, many definitions are missing, but the ones
that are filled-in will describe alkane CH3, alkane H,
alkene C, and alkene H.
Based on SMARTS definitions, Foyer detects all the possible 
SMARTS pattern matches for every atom.

SMARTS-strings can be as general or specific as you want.
This is helpful for implementing some force fields, or developing
a new atom type that should only be used in a very particular molecular
pattern.
If a particular atom satisfies multiple SMARTS definitions, and thus
could be multiple atom types, Foyer helps narrow down to
a single atom type via `overrides`.
No easy examples to show, but [here](https://github.com/mosdef-hub/foyer/tree/master/foyer/forcefields) 
you can find `oplsaa.xml` with examples of overrides.
Here's a use-case, you have a carbon that fits atomtypes
C1, C2, C3, and C4.
But you also have overrides definied, such that C2 overrides C1, 
C3 overrides C2, and C4 overrides C3.
Alternatively, you could have C4 override C3, C2, and C1.
Because of this priority/precedence, your carbon will get defined 
as C4.

The remaining sections within the FFXML file outline the 
different forces that this FF implements.
Again, the Foyer-supported parameters are [here](https://github.com/mosdef-hub/foyer/blob/master/docs/parameter_definitions.rst),
and we derive these objects/forces from OpenMM-style [here](http://docs.openmm.org/latest/userguide/theory.html). 
If you wanted to incorporate a new functional term, it would
have to abide by the OpenMM conventions prior to being 
implemented within Foyer.


## Foyer Forcefield class
We've outlined the FFXML, but now we need to create
an object from this text.
This is where the `Forcefield` class comes into play.
The class is defined in [here](https://github.com/mosdef-hub/foyer/blob/9a4fec2c3b177302d772ca22d52c075d0d7ea31a/foyer/forcefield.py#L327).
The Foyer FF class inherits from the [OpenMM FF Class](https://github.com/pandegroup/openmm/blob/master/wrappers/python/simtk/openmm/app/forcefield.py),
so some functionality gets re-used (one example is the parameter
assignment is taken from the OpenMM FF).
Within the Foyer FF class, there is the Foyer-specific information
like definitions, overrides, descriptions, dois, etc.
Within the OpenMM FF class (the superclass), there is the OpenMM information
like the atom types and forces, among other fields that don't get 
utilized in Foyer.

In addition to creating digitizing the FFXML into a FF object,
the forces also described in the FFXML also get turned into their own
Force objects.

In actuality, the forces described in the FFXML get turned into
ForceGenerators [like this](https://github.com/openmm/openmm/blob/a9ea2b9be1208db8e3268d2ce352643fa694c727/wrappers/python/simtk/openmm/app/forcefield.py#L1824).
Further down the pipeline/workflow, these generators will later
create their respective Force objects,
which are found elsewhere in the OpenMM [C code](https://github.com/openmm/openmm/tree/f9106ddb6a0d72c960c73b23ed0e07cd7190a80f/openmmapi/include/openmm).

In summary, the Foyer FF class turns the FFXML into a data structure
that contains information about the atomtypes, classes, forces, and 
everything else that went into the FFXML.

## Applying a Foyer FF
We now have our FF object with which we can interact using Foyer's API.
The next thing is to take this FF and apply it to our chemical
system of choice, identifying the atom types and interaction parameters
according to the FF, this building our molecular model.
Correspondingly, the method is [`Forcefield.apply`](https://github.com/mosdef-hub/foyer/blob/9a4fec2c3b177302d772ca22d52c075d0d7ea31a/foyer/forcefield.py#L449)

The apply step can be broken into 4 steps

### FF Applying, step 1: Preparing a topology
To apply a force field, you need to provide a chemical topology.
This topology needs to know the elements of all the atoms/particles
in your system, and all the bonds between them.
There are MANY flavors of a chemical topology, but they
all end up converted to an `OpenMM.Topology`.
Additional information in the `OpenMM.Topology` 
include residues and chains. 
Thus far, only residue functionality is encoded;
while residues are technically associated with proteins
and amino acids, residues can also generically
refer to a molecule type in our system (if you have a box
of ethanes and methanes, the all the ethanes would be of the
ethane residue, even if you have 10 distinct ethane molecules)

### FF Applying, step 2: Atomtyping
After consolidating any chemical topology input
into an `OpenMM.Topology`, we now iterate 
through the atoms to identify each atom's atom type.
This is the majority of the Foyer API.
The gist is that we try to find all the SMARTS patterns
and atom types that fit each atom in our topology. 
Using overrides functionality, we help narrow down
a list of possible atom types to a single one.
This is often a pain point in the Foyer workflow,
as sometimes overrides or SMARTS definitions are poorly
defined. 
If overrides are not sufficiently defined, narrowing down
the possible atom types to just one will not work.
If SMARTS definitions are not sufficiently defined,
some atoms in your topology will not fit any atom type
as defined in your FFXML (or maybe something was wrong
with your chemical topology).

If you are interested in digging deeper into
the Foyer atomtyping API, there will be sections later in this post.

### FF Applying, step 3: Parametrize the forces
Once all atom types have been detected within our topology,
we use some functionality from OpenMM to parametrize all the 
interactions within our chemical system.

Remembering that the FFXML -> FF object actually conatined
ForceGenerators, not the actual Forces,
this step now creates the Forces and identifies all the
relevant atoms, bonds, angles, dihedrals, etc.
to which that Force applies.

This step yields an `OpenMM.System` object.
Within the Foyer workflow, this gets converted to a `ParmEd.Structure`.

### FF Applying, (optional) step 4: Validation
When building a molecular model, sanity checks are necessary.
Do all bonds have parameters defined? What about angles and dihedrals?
Foyer includes functionality to sanity check the resultant
parametrized `ParmEd.Structure`.
As a note, most (if not all) FFs define bond interactions (two-atom partners
directly bonded).
Angles and dihedrals may not always be defined or
parametrized within that FF,
and that's okay if that's what the FF correctly states.

Additionally, if the FFXML had DOIs associated with it,
the DOIs get written to a bibtex file, helpful for properly
citing and creditin authors of the FF.

## Done applying a Foyer FF
At this point, we have a parametrized `ParmEd.Structure` object,
in which all atoms have atom types, and all physical interactions
are defined with parameters (provided they were specified in the FFXML).
From this `ParmEd.Structure` we perform a variety of different
data structure conversions or I/O to different file formats
suitable to the engine of choice.

If you are using or interested in using Foyer, hopefully this is enough
design and implementation detail to get you comfortable with the API.
The goal is to provide a tool that helps atomtype and parametrize
arbitrary chemical systems in a manner that users can walk through,
debug, and fine-tune a force field as necessary.

# An in-depth dive into the Foyer API
If you are a maintainer or developer of Foyer, this will
hopefully help you get a better sense of how the code works,
as a lot of the internal API is hidden from users.
We will, once again, walk through the Foyer API and workflow,
but with a lot more detail.

## More about the Foyer FFXML and Forcefield
The FFXML does follow the XML structure, and can be
manipulated using `lxml` or `xml` Python libaries.

